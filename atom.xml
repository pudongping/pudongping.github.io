<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>热浪编程</title>
  
  <subtitle>蒲东平的博客</subtitle>
  <link href="https://pudongping.github.io/atom.xml" rel="self"/>
  
  <link href="https://pudongping.github.io/"/>
  <updated>2025-09-01T02:33:36.330Z</updated>
  <id>https://pudongping.github.io/</id>
  
  <author>
    <name>Alex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git合并选Rebase还是Merge？弄懂这3点，从此不再纠结</title>
    <link href="https://pudongping.github.io/posts/a479708b.html"/>
    <id>https://pudongping.github.io/posts/a479708b.html</id>
    <published>2025-09-01T02:32:55.000Z</published>
    <updated>2025-09-01T02:33:36.330Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;大家好！今天我们来聊聊 Git 中两个非常重要但又容易混淆的概念：&lt;code&gt;git rebase&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在日常团队协作开发中，我们经常需要将不同分支的代码进行合并。Git</summary>
        
      
    
    
    
    <category term="Git" scheme="https://pudongping.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="https://pudongping.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>搞懂 ELK 日志系统架构，这一篇就够了（含实战图解）</title>
    <link href="https://pudongping.github.io/posts/cbdca962.html"/>
    <id>https://pudongping.github.io/posts/cbdca962.html</id>
    <published>2025-08-28T03:30:26.000Z</published>
    <updated>2025-08-28T03:33:12.525Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;随着系统架构的不断扩展和业务规模的迅猛增长，传统的日志管理方式已经难以应对海量分布式系统中的日志收集、查询和告警需求。为此，越来越多的企业开始引入成熟的日志系统方案，&lt;strong&gt;Elastic Stack（即 ELK + Beats）&lt;/strong&gt;</summary>
        
      
    
    
    
    <category term="微服务" scheme="https://pudongping.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="ElasticSearch" scheme="https://pudongping.github.io/tags/ElasticSearch/"/>
    
    <category term="Kibana" scheme="https://pudongping.github.io/tags/Kibana/"/>
    
    <category term="微服务" scheme="https://pudongping.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="ELK" scheme="https://pudongping.github.io/tags/ELK/"/>
    
    <category term="logstash" scheme="https://pudongping.github.io/tags/logstash/"/>
    
    <category term="Filebeat" scheme="https://pudongping.github.io/tags/Filebeat/"/>
    
  </entry>
  
  <entry>
    <title>从入门到实战：一文掌握微服务监控系统 Prometheus + Grafana</title>
    <link href="https://pudongping.github.io/posts/17b9f045.html"/>
    <id>https://pudongping.github.io/posts/17b9f045.html</id>
    <published>2025-08-27T03:33:43.000Z</published>
    <updated>2025-08-27T03:35:01.639Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;随着微服务架构的广泛应用，系统组件之间的交互变得更加复杂。为了及时发现故障、评估性能瓶颈并提升系统可观测性，构建一套完善的&lt;strong&gt;监控系统&lt;/strong&gt;成为了现代微服务体系中的标配。&lt;/p&gt;
&lt;p&gt;本文将围绕 Prometheus 这一主流开源监控系统，结合</summary>
        
      
    
    
    
    <category term="微服务" scheme="https://pudongping.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="https://pudongping.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Prometheus" scheme="https://pudongping.github.io/tags/Prometheus/"/>
    
    <category term="Grafana" scheme="https://pudongping.github.io/tags/Grafana/"/>
    
    <category term="监控" scheme="https://pudongping.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>高并发系统下，如何用限流算法优雅地保护你的服务？</title>
    <link href="https://pudongping.github.io/posts/e05f1cd5.html"/>
    <id>https://pudongping.github.io/posts/e05f1cd5.html</id>
    <published>2025-08-26T02:12:34.000Z</published>
    <updated>2025-08-26T02:14:47.365Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在微服务架构盛行的今天，服务间的调用链路变得越来越复杂。一个看似平静的系统，往往在瞬间的流量洪峰面前不堪一击。当双11零点、热门事件爆发、或者恶意攻击来临时，如何确保我们的服务能够稳定运行，而不是在流量面前缴械投降？&lt;/p&gt;
&lt;p&gt;回答就是：&lt;strong&gt;限流&lt;/stro</summary>
        
      
    
    
    
    <category term="微服务" scheme="https://pudongping.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="https://pudongping.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="限流" scheme="https://pudongping.github.io/tags/%E9%99%90%E6%B5%81/"/>
    
    <category term="漏桶" scheme="https://pudongping.github.io/tags/%E6%BC%8F%E6%A1%B6/"/>
    
    <category term="令牌桶" scheme="https://pudongping.github.io/tags/%E4%BB%A4%E7%89%8C%E6%A1%B6/"/>
    
    <category term="熔断" scheme="https://pudongping.github.io/tags/%E7%86%94%E6%96%AD/"/>
    
    <category term="降级" scheme="https://pudongping.github.io/tags/%E9%99%8D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>微服务稳定性三板斧：熔断、限流与负载均衡全面解析（附 Hystrix-Go 实战代码）</title>
    <link href="https://pudongping.github.io/posts/1a4a443b.html"/>
    <id>https://pudongping.github.io/posts/1a4a443b.html</id>
    <published>2025-08-25T02:03:30.000Z</published>
    <updated>2025-08-25T02:04:22.170Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在构建微服务架构的过程中，“高可用”和“稳定性”始终是绕不开的关键词。服务间依赖错综复杂，一旦某个下游服务出现性能瓶颈或故障，就可能引发“雪崩效应”，造成整条链路瘫痪。为了避免这种灾难性后果，我们引入了三项关键技术：&lt;strong&gt;熔断&lt;/strong&gt;、&lt;strong&gt;限</summary>
        
      
    
    
    
    <category term="微服务" scheme="https://pudongping.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="https://pudongping.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="限流" scheme="https://pudongping.github.io/tags/%E9%99%90%E6%B5%81/"/>
    
    <category term="熔断" scheme="https://pudongping.github.io/tags/%E7%86%94%E6%96%AD/"/>
    
    <category term="负载均衡" scheme="https://pudongping.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Jaeger，一个链路追踪神器！</title>
    <link href="https://pudongping.github.io/posts/f542f6b5.html"/>
    <id>https://pudongping.github.io/posts/f542f6b5.html</id>
    <published>2025-08-22T02:49:14.000Z</published>
    <updated>2025-08-22T02:50:14.086Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在微服务系统中，一个接口请求可能穿越十几个服务节点，复杂度远超传统单体应用。此时，如何追踪一次请求的全链路信息、快速定位问题、优化性能，成为了运维与开发必须直面的挑战。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“如果你不能度量它，你就无法改进它。” ——</summary>
        
      
    
    
    
    <category term="微服务" scheme="https://pudongping.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="https://pudongping.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="jaeger" scheme="https://pudongping.github.io/tags/jaeger/"/>
    
    <category term="链路追踪" scheme="https://pudongping.github.io/tags/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>全面掌握 Consul：服务注册发现、健康检查、跨数据中心一网打尽</title>
    <link href="https://pudongping.github.io/posts/38329174.html"/>
    <id>https://pudongping.github.io/posts/38329174.html</id>
    <published>2025-08-21T02:17:26.000Z</published>
    <updated>2025-08-21T02:18:44.699Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在微服务架构快速发展的今天，服务之间的通信与协调变得愈发复杂。一个高效、稳定、具备服务注册与发现能力的中间件，几乎是构建高可用系统的“刚需”。&lt;strong&gt;Consul&lt;/strong&gt;</summary>
        
      
    
    
    
    <category term="微服务" scheme="https://pudongping.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Consul" scheme="https://pudongping.github.io/tags/Consul/"/>
    
    <category term="微服务" scheme="https://pudongping.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="服务注册发现" scheme="https://pudongping.github.io/tags/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/"/>
    
    <category term="健康检查" scheme="https://pudongping.github.io/tags/%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>gRPC凭什么成为微服务通信首选？深度解析RPC进化史</title>
    <link href="https://pudongping.github.io/posts/610da067.html"/>
    <id>https://pudongping.github.io/posts/610da067.html</id>
    <published>2025-08-20T02:03:11.000Z</published>
    <updated>2025-08-20T02:04:02.801Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在构建分布式系统或微服务架构时，&lt;strong&gt;服务之间的通信机制&lt;/strong&gt;往往决定了整个系统的性能与可维护性。&lt;/p&gt;
&lt;p&gt;本文将围绕 RPC 和 gRPC 展开，详细介绍它们的原理、优势及使用方式，并深入讲解 gRPC 所依赖的序列化协议 ——</summary>
        
      
    
    
    
    <category term="微服务" scheme="https://pudongping.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="https://pudongping.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="gRPC" scheme="https://pudongping.github.io/tags/gRPC/"/>
    
    <category term="RPC" scheme="https://pudongping.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>微服务不是银弹！这4个设计原则让你少踩90%的坑</title>
    <link href="https://pudongping.github.io/posts/df453781.html"/>
    <id>https://pudongping.github.io/posts/df453781.html</id>
    <published>2025-08-19T02:45:59.000Z</published>
    <updated>2025-08-19T02:47:00.837Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;随着业务复杂度的不断提升和敏捷开发理念的普及，微服务架构已经成为现代软件工程中的主流选择。但很多团队在实施微服务时常常陷入误区：要么拆得过细导致维护困难，要么边界模糊变成“分布式单体”。要真正掌握微服务的精髓，领域驱动设计（DDD）无疑是不可或缺的一把钥匙。&lt;/p&gt;
&lt;p&gt;</summary>
        
      
    
    
    
    <category term="微服务" scheme="https://pudongping.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="https://pudongping.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="设计模式" scheme="https://pudongping.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="设计原则" scheme="https://pudongping.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Cookie、Session、Token、JWT 是什么？万字图解带你一次搞懂！看完这篇，你连老奶奶都能教</title>
    <link href="https://pudongping.github.io/posts/65239a79.html"/>
    <id>https://pudongping.github.io/posts/65239a79.html</id>
    <published>2025-08-14T04:01:10.000Z</published>
    <updated>2025-08-14T04:02:51.509Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在讲这几个专业术语之前，我们先看一下这样的场景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你去银行准备办理业务，柜台工作人员礼貌地问你：“请问您要办理什么业务？”&lt;br&gt;你说：“我要查询我还有多少余额。”&lt;br&gt;等工作人员处理完之后，你紧接着说：“我还想转账 1000</summary>
        
      
    
    
    
    <category term="科普" scheme="https://pudongping.github.io/categories/%E7%A7%91%E6%99%AE/"/>
    
    
    <category term="Cookie" scheme="https://pudongping.github.io/tags/Cookie/"/>
    
    <category term="Session" scheme="https://pudongping.github.io/tags/Session/"/>
    
    <category term="Token" scheme="https://pudongping.github.io/tags/Token/"/>
    
    <category term="安全" scheme="https://pudongping.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="授权" scheme="https://pudongping.github.io/tags/%E6%8E%88%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>3分钟，手摸手教你用OpenResty搭建高性能隧道代理（附完整配置！）</title>
    <link href="https://pudongping.github.io/posts/c2b7a51a.html"/>
    <id>https://pudongping.github.io/posts/c2b7a51a.html</id>
    <published>2025-08-14T04:00:44.000Z</published>
    <updated>2025-08-14T04:02:51.509Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;经常写爬虫的小伙伴们对代理 IP 应该不会很陌生了吧？&lt;/p&gt;
&lt;p&gt;通常，我们为了让爬虫更加稳定，一般我们都会去购买一些代理 IP 用在我们的爬虫服务上。常规的做法，我们一般会去某个代理网站上面购买服务，然后我们会得到一个获取代理 IP</summary>
        
      
    
    
    
    <category term="科普" scheme="https://pudongping.github.io/categories/%E7%A7%91%E6%99%AE/"/>
    
    
    <category term="OpenResty" scheme="https://pudongping.github.io/tags/OpenResty/"/>
    
    <category term="Nginx" scheme="https://pudongping.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>一文吃透 Promise 与 async/await，异步编程也能如此简单！建议收藏！</title>
    <link href="https://pudongping.github.io/posts/da88494b.html"/>
    <id>https://pudongping.github.io/posts/da88494b.html</id>
    <published>2025-08-12T03:39:29.000Z</published>
    <updated>2025-08-12T03:42:15.992Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在现代编程开发中，“异步”两个字几乎贯穿始终：你写的接口请求、定时器、事件监听、动画控制……背后都绕不开异步编程。&lt;/p&gt;
&lt;p&gt;那到底啥是&lt;strong&gt;异步&lt;/strong&gt;呢？说到异步，我们就需要结合&lt;strong&gt;同步&lt;/strong&gt;来讲讲，这样就更加清晰明了。&lt;</summary>
        
      
    
    
    
    <category term="前端" scheme="https://pudongping.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="异步编程" scheme="https://pudongping.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    <category term="前端" scheme="https://pudongping.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="promise" scheme="https://pudongping.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>你真的懂 close(chan) 吗？90% 的 Go 开发者都掉过这个坑！</title>
    <link href="https://pudongping.github.io/posts/5e6d50e0.html"/>
    <id>https://pudongping.github.io/posts/5e6d50e0.html</id>
    <published>2025-08-08T03:08:45.000Z</published>
    <updated>2025-08-08T03:09:30.585Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在日常 Go 并发编程中，我们可能会看到类似以下这样的代码：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-go&quot; data-language=&quot;go&quot;&gt;&lt;code class=&quot;language-go&quot;&gt;&lt;span class=&quot;token</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>用 Go 写桌面应用？试试 Wails 吧！</title>
    <link href="https://pudongping.github.io/posts/f3f6160c.html"/>
    <id>https://pudongping.github.io/posts/f3f6160c.html</id>
    <published>2025-08-07T02:12:34.000Z</published>
    <updated>2025-08-07T02:13:45.009Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在前端开发中，提起桌面应用，很多人第一反应是 &lt;strong&gt;Electron&lt;/strong&gt;。虽然它很流行，但不可否认也“很重” —— 内存占用高、打包体积大。&lt;/p&gt;
&lt;p&gt;有没有更轻量的选择呢？当然有！今天我们来聊一聊一个非常有意思的项目 ——</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
    <category term="Wails" scheme="https://pudongping.github.io/tags/Wails/"/>
    
  </entry>
  
  <entry>
    <title>Conc，一个神奇的Go语言并发利器！</title>
    <link href="https://pudongping.github.io/posts/1e620500.html"/>
    <id>https://pudongping.github.io/posts/1e620500.html</id>
    <published>2025-08-07T02:11:13.000Z</published>
    <updated>2025-08-07T02:13:45.007Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 Go 语言中，goroutine 和通道是并发编程的核心，但随着项目复杂度的增加，管理成百上千个 goroutine 并确保它们正确协作变得极具挑战性。&lt;code&gt;sourcegraph/conc&lt;/code&gt;</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
    <category term="Conc" scheme="https://pudongping.github.io/tags/Conc/"/>
    
  </entry>
  
  <entry>
    <title>Wire，一个神奇的Go依赖注入神器！</title>
    <link href="https://pudongping.github.io/posts/68a189a1.html"/>
    <id>https://pudongping.github.io/posts/68a189a1.html</id>
    <published>2025-08-07T02:10:15.000Z</published>
    <updated>2025-08-07T02:13:45.008Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在介绍 wire 工具之前，我们先聊聊什么是控制反转（IoC）与依赖注入（DI）？它们解决了什么问题？&lt;/p&gt;
&lt;h2 id=&quot;控制反转（IoC）与依赖注入（DI）&quot;&gt;&lt;a href=&quot;#控制反转（IoC）与依赖注入（DI）&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
    <category term="Wire" scheme="https://pudongping.github.io/tags/Wire/"/>
    
  </entry>
  
  <entry>
    <title>告别缓存击穿！Go 语言中的防并发神器：singleflight 包深度解析</title>
    <link href="https://pudongping.github.io/posts/3b25df61.html"/>
    <id>https://pudongping.github.io/posts/3b25df61.html</id>
    <published>2025-08-07T02:08:53.000Z</published>
    <updated>2025-08-07T02:13:45.009Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在高并发场景下，我们常常遇到多个请求同时访问同一份资源的情况。例如，当缓存失效时，大量请求可能同时触发数据库查询，造成资源浪费甚至数据库崩溃。为了解决这一问题， Go 语言提供了 &lt;code&gt;singleflight&lt;/code&gt; 包 ，它能够将多个相同 key</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
    <category term="singleflight" scheme="https://pudongping.github.io/tags/singleflight/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言单例模式全解析：从青铜到王者段位的实现方案</title>
    <link href="https://pudongping.github.io/posts/eb161174.html"/>
    <id>https://pudongping.github.io/posts/eb161174.html</id>
    <published>2025-06-29T06:39:36.000Z</published>
    <updated>2025-08-07T02:04:26.003Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;什么是单例模式？&quot;&gt;&lt;a href=&quot;#什么是单例模式？&quot; class=&quot;headerlink&quot; title=&quot;什么是单例模式？&quot;&gt;&lt;/a&gt;什么是单例模式？&lt;/h2&gt;&lt;p&gt;单例模式（Singleton</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>如何为 gRPC Server 编写本地测试代码</title>
    <link href="https://pudongping.github.io/posts/e9966a07.html"/>
    <id>https://pudongping.github.io/posts/e9966a07.html</id>
    <published>2025-06-26T01:52:58.000Z</published>
    <updated>2025-08-07T02:04:26.003Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在微服务架构中，gRPC 已成为主流的通信协议之一。但许多开发者在面对 gRPC 服务测试时，常常会遇到需要启动真实网络服务、管理端口占用等烦恼。&lt;/p&gt;
&lt;p&gt;本文将介绍如何利用 Go 语言中 gRPC 提供的测试工具 ——</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
    <category term="gRPC" scheme="https://pudongping.github.io/tags/gRPC/"/>
    
    <category term="RPC" scheme="https://pudongping.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言中如何处理并发错误</title>
    <link href="https://pudongping.github.io/posts/d082e483.html"/>
    <id>https://pudongping.github.io/posts/d082e483.html</id>
    <published>2025-06-25T02:14:34.000Z</published>
    <updated>2025-08-07T02:04:26.003Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 Go 语言中，错误处理一直是开发中不可或缺的一部分。尤其在并发编程场景下，由于多个 goroutine 同时运行，错误的传递和处理就变得更为复杂。这篇文章就介绍了一些常见的处理并发错误的方法，以供各位参考。&lt;/p&gt;
&lt;p&gt;&lt;img</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
