<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>热浪编程</title>
  
  <subtitle>蒲东平的博客</subtitle>
  <link href="https://pudongping.github.io/atom.xml" rel="self"/>
  
  <link href="https://pudongping.github.io/"/>
  <updated>2025-08-20T02:03:58.369Z</updated>
  <id>https://pudongping.github.io/</id>
  
  <author>
    <name>Alex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gRPC凭什么成为微服务通信首选？深度解析RPC进化史</title>
    <link href="https://pudongping.github.io/posts/610da067.html"/>
    <id>https://pudongping.github.io/posts/610da067.html</id>
    <published>2025-08-20T02:03:11.000Z</published>
    <updated>2025-08-20T02:03:58.369Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在构建分布式系统或微服务架构时，&lt;strong&gt;服务之间的通信机制&lt;/strong&gt;往往决定了整个系统的性能与可维护性。&lt;/p&gt;
&lt;p&gt;本文将围绕 RPC 和 gRPC 展开，详细介绍它们的原理、优势及使用方式，并深入讲解 gRPC 所依赖的序列化协议 ——</summary>
        
      
    
    
    
    <category term="微服务" scheme="https://pudongping.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="https://pudongping.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="gRPC" scheme="https://pudongping.github.io/tags/gRPC/"/>
    
    <category term="RPC" scheme="https://pudongping.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>微服务不是银弹！这4个设计原则让你少踩90%的坑</title>
    <link href="https://pudongping.github.io/posts/df453781.html"/>
    <id>https://pudongping.github.io/posts/df453781.html</id>
    <published>2025-08-19T02:45:59.000Z</published>
    <updated>2025-08-19T02:47:00.837Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;随着业务复杂度的不断提升和敏捷开发理念的普及，微服务架构已经成为现代软件工程中的主流选择。但很多团队在实施微服务时常常陷入误区：要么拆得过细导致维护困难，要么边界模糊变成“分布式单体”。要真正掌握微服务的精髓，领域驱动设计（DDD）无疑是不可或缺的一把钥匙。&lt;/p&gt;
&lt;p&gt;</summary>
        
      
    
    
    
    <category term="微服务" scheme="https://pudongping.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="https://pudongping.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="设计模式" scheme="https://pudongping.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="设计原则" scheme="https://pudongping.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Cookie、Session、Token、JWT 是什么？万字图解带你一次搞懂！看完这篇，你连老奶奶都能教</title>
    <link href="https://pudongping.github.io/posts/65239a79.html"/>
    <id>https://pudongping.github.io/posts/65239a79.html</id>
    <published>2025-08-14T04:01:10.000Z</published>
    <updated>2025-08-14T04:02:51.509Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在讲这几个专业术语之前，我们先看一下这样的场景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你去银行准备办理业务，柜台工作人员礼貌地问你：“请问您要办理什么业务？”&lt;br&gt;你说：“我要查询我还有多少余额。”&lt;br&gt;等工作人员处理完之后，你紧接着说：“我还想转账 1000</summary>
        
      
    
    
    
    <category term="科普" scheme="https://pudongping.github.io/categories/%E7%A7%91%E6%99%AE/"/>
    
    
    <category term="Cookie" scheme="https://pudongping.github.io/tags/Cookie/"/>
    
    <category term="Session" scheme="https://pudongping.github.io/tags/Session/"/>
    
    <category term="Token" scheme="https://pudongping.github.io/tags/Token/"/>
    
    <category term="安全" scheme="https://pudongping.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="授权" scheme="https://pudongping.github.io/tags/%E6%8E%88%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>3分钟，手摸手教你用OpenResty搭建高性能隧道代理（附完整配置！）</title>
    <link href="https://pudongping.github.io/posts/c2b7a51a.html"/>
    <id>https://pudongping.github.io/posts/c2b7a51a.html</id>
    <published>2025-08-14T04:00:44.000Z</published>
    <updated>2025-08-14T04:02:51.509Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;经常写爬虫的小伙伴们对代理 IP 应该不会很陌生了吧？&lt;/p&gt;
&lt;p&gt;通常，我们为了让爬虫更加稳定，一般我们都会去购买一些代理 IP 用在我们的爬虫服务上。常规的做法，我们一般会去某个代理网站上面购买服务，然后我们会得到一个获取代理 IP</summary>
        
      
    
    
    
    <category term="科普" scheme="https://pudongping.github.io/categories/%E7%A7%91%E6%99%AE/"/>
    
    
    <category term="OpenResty" scheme="https://pudongping.github.io/tags/OpenResty/"/>
    
    <category term="Nginx" scheme="https://pudongping.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>一文吃透 Promise 与 async/await，异步编程也能如此简单！建议收藏！</title>
    <link href="https://pudongping.github.io/posts/da88494b.html"/>
    <id>https://pudongping.github.io/posts/da88494b.html</id>
    <published>2025-08-12T03:39:29.000Z</published>
    <updated>2025-08-12T03:42:15.992Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在现代编程开发中，“异步”两个字几乎贯穿始终：你写的接口请求、定时器、事件监听、动画控制……背后都绕不开异步编程。&lt;/p&gt;
&lt;p&gt;那到底啥是&lt;strong&gt;异步&lt;/strong&gt;呢？说到异步，我们就需要结合&lt;strong&gt;同步&lt;/strong&gt;来讲讲，这样就更加清晰明了。&lt;</summary>
        
      
    
    
    
    <category term="前端" scheme="https://pudongping.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="异步编程" scheme="https://pudongping.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    <category term="前端" scheme="https://pudongping.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="promise" scheme="https://pudongping.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>你真的懂 close(chan) 吗？90% 的 Go 开发者都掉过这个坑！</title>
    <link href="https://pudongping.github.io/posts/5e6d50e0.html"/>
    <id>https://pudongping.github.io/posts/5e6d50e0.html</id>
    <published>2025-08-08T03:08:45.000Z</published>
    <updated>2025-08-08T03:09:30.585Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在日常 Go 并发编程中，我们可能会看到类似以下这样的代码：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-go&quot; data-language=&quot;go&quot;&gt;&lt;code class=&quot;language-go&quot;&gt;&lt;span class=&quot;token</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>用 Go 写桌面应用？试试 Wails 吧！</title>
    <link href="https://pudongping.github.io/posts/f3f6160c.html"/>
    <id>https://pudongping.github.io/posts/f3f6160c.html</id>
    <published>2025-08-07T02:12:34.000Z</published>
    <updated>2025-08-07T02:13:45.009Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在前端开发中，提起桌面应用，很多人第一反应是 &lt;strong&gt;Electron&lt;/strong&gt;。虽然它很流行，但不可否认也“很重” —— 内存占用高、打包体积大。&lt;/p&gt;
&lt;p&gt;有没有更轻量的选择呢？当然有！今天我们来聊一聊一个非常有意思的项目 ——</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
    <category term="Wails" scheme="https://pudongping.github.io/tags/Wails/"/>
    
  </entry>
  
  <entry>
    <title>Conc，一个神奇的Go语言并发利器！</title>
    <link href="https://pudongping.github.io/posts/1e620500.html"/>
    <id>https://pudongping.github.io/posts/1e620500.html</id>
    <published>2025-08-07T02:11:13.000Z</published>
    <updated>2025-08-07T02:13:45.007Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 Go 语言中，goroutine 和通道是并发编程的核心，但随着项目复杂度的增加，管理成百上千个 goroutine 并确保它们正确协作变得极具挑战性。&lt;code&gt;sourcegraph/conc&lt;/code&gt;</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
    <category term="Conc" scheme="https://pudongping.github.io/tags/Conc/"/>
    
  </entry>
  
  <entry>
    <title>Wire，一个神奇的Go依赖注入神器！</title>
    <link href="https://pudongping.github.io/posts/68a189a1.html"/>
    <id>https://pudongping.github.io/posts/68a189a1.html</id>
    <published>2025-08-07T02:10:15.000Z</published>
    <updated>2025-08-07T02:13:45.008Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在介绍 wire 工具之前，我们先聊聊什么是控制反转（IoC）与依赖注入（DI）？它们解决了什么问题？&lt;/p&gt;
&lt;h2 id=&quot;控制反转（IoC）与依赖注入（DI）&quot;&gt;&lt;a href=&quot;#控制反转（IoC）与依赖注入（DI）&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
    <category term="Wire" scheme="https://pudongping.github.io/tags/Wire/"/>
    
  </entry>
  
  <entry>
    <title>告别缓存击穿！Go 语言中的防并发神器：singleflight 包深度解析</title>
    <link href="https://pudongping.github.io/posts/3b25df61.html"/>
    <id>https://pudongping.github.io/posts/3b25df61.html</id>
    <published>2025-08-07T02:08:53.000Z</published>
    <updated>2025-08-07T02:13:45.009Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在高并发场景下，我们常常遇到多个请求同时访问同一份资源的情况。例如，当缓存失效时，大量请求可能同时触发数据库查询，造成资源浪费甚至数据库崩溃。为了解决这一问题， Go 语言提供了 &lt;code&gt;singleflight&lt;/code&gt; 包 ，它能够将多个相同 key</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
    <category term="singleflight" scheme="https://pudongping.github.io/tags/singleflight/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言单例模式全解析：从青铜到王者段位的实现方案</title>
    <link href="https://pudongping.github.io/posts/eb161174.html"/>
    <id>https://pudongping.github.io/posts/eb161174.html</id>
    <published>2025-06-29T06:39:36.000Z</published>
    <updated>2025-08-07T02:04:26.003Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;什么是单例模式？&quot;&gt;&lt;a href=&quot;#什么是单例模式？&quot; class=&quot;headerlink&quot; title=&quot;什么是单例模式？&quot;&gt;&lt;/a&gt;什么是单例模式？&lt;/h2&gt;&lt;p&gt;单例模式（Singleton</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>如何为 gRPC Server 编写本地测试代码</title>
    <link href="https://pudongping.github.io/posts/e9966a07.html"/>
    <id>https://pudongping.github.io/posts/e9966a07.html</id>
    <published>2025-06-26T01:52:58.000Z</published>
    <updated>2025-08-07T02:04:26.003Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在微服务架构中，gRPC 已成为主流的通信协议之一。但许多开发者在面对 gRPC 服务测试时，常常会遇到需要启动真实网络服务、管理端口占用等烦恼。&lt;/p&gt;
&lt;p&gt;本文将介绍如何利用 Go 语言中 gRPC 提供的测试工具 ——</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
    <category term="gRPC" scheme="https://pudongping.github.io/tags/gRPC/"/>
    
    <category term="RPC" scheme="https://pudongping.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言中如何处理并发错误</title>
    <link href="https://pudongping.github.io/posts/d082e483.html"/>
    <id>https://pudongping.github.io/posts/d082e483.html</id>
    <published>2025-06-25T02:14:34.000Z</published>
    <updated>2025-08-07T02:04:26.003Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 Go 语言中，错误处理一直是开发中不可或缺的一部分。尤其在并发编程场景下，由于多个 goroutine 同时运行，错误的传递和处理就变得更为复杂。这篇文章就介绍了一些常见的处理并发错误的方法，以供各位参考。&lt;/p&gt;
&lt;p&gt;&lt;img</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 go 语言中的 select 语句</title>
    <link href="https://pudongping.github.io/posts/14df232b.html"/>
    <id>https://pudongping.github.io/posts/14df232b.html</id>
    <published>2025-06-24T02:25:25.000Z</published>
    <updated>2025-08-07T02:04:26.004Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 go 语言中，&lt;code&gt;select&lt;/code&gt; 是 Go 语言专门为并发编程设计的控制结构，主要用于在多个 channel 操作之间进行非阻塞选择。它的工作方式类似于 &lt;code&gt;switch&lt;/code&gt;，但所有 case 分支都必须是 channel 的</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>InfluxDB 时序数据的高效解决方案</title>
    <link href="https://pudongping.github.io/posts/84187b70.html"/>
    <id>https://pudongping.github.io/posts/84187b70.html</id>
    <published>2025-06-23T08:42:10.000Z</published>
    <updated>2025-08-07T02:04:26.003Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;InfluxDB-是什么？&quot;&gt;&lt;a href=&quot;#InfluxDB-是什么？&quot; class=&quot;headerlink&quot; title=&quot;InfluxDB 是什么？&quot;&gt;&lt;/a&gt;InfluxDB</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
    <category term="数据库" scheme="https://pudongping.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="DB" scheme="https://pudongping.github.io/tags/DB/"/>
    
    <category term="InfluxDB" scheme="https://pudongping.github.io/tags/InfluxDB/"/>
    
  </entry>
  
  <entry>
    <title>不用WebSocket也能搞定实时消息推送？试一试SSE吧！</title>
    <link href="https://pudongping.github.io/posts/5a7767cc.html"/>
    <id>https://pudongping.github.io/posts/5a7767cc.html</id>
    <published>2025-06-18T01:49:34.000Z</published>
    <updated>2025-06-18T01:50:59.553Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在现代 Web 开发中，实现实时数据更新是一个常见的需求。比如股票行情、聊天消息、体育比赛比分等场景，都需要服务器能够主动将数据推送给客户端，而不是客户端频繁轮询服务器来获取最新数据。&lt;/p&gt;
&lt;p&gt;今天，我们就来学习如何使用 Go 语言和 Gin 框架实现</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言切片，使用技巧与避坑指南</title>
    <link href="https://pudongping.github.io/posts/96775eb5.html"/>
    <id>https://pudongping.github.io/posts/96775eb5.html</id>
    <published>2025-06-17T01:51:12.000Z</published>
    <updated>2025-06-17T01:51:56.237Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;切片（Slice）是Go语言中最灵活且高频使用的数据结构之一，其本质是&lt;strong&gt;对底层数组的动态引用视图&lt;/strong&gt;，支持动态扩容、高效截取等特性。&lt;/p&gt;
&lt;p&gt;本文将结合代码示例，详细解析切片的核心用法及常见注意事项。&lt;/p&gt;
&lt;h2</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中使用切片需要注意什么？</title>
    <link href="https://pudongping.github.io/posts/816dc455.html"/>
    <id>https://pudongping.github.io/posts/816dc455.html</id>
    <published>2025-06-16T02:40:21.000Z</published>
    <updated>2025-06-16T02:41:06.879Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;切片（Slice）是 Go 语言中非常强大且灵活的数据结构，它是对数组的一个连续片段的引用。切片的使用极大地简化了数组的操作，但在使用过程中也有一些需要注意的地方。&lt;/p&gt;
&lt;p&gt;本文将详细介绍在 Go</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>你真的会使用 Go 语言中的 Channel 吗？</title>
    <link href="https://pudongping.github.io/posts/2a20e737.html"/>
    <id>https://pudongping.github.io/posts/2a20e737.html</id>
    <published>2025-06-13T01:53:51.000Z</published>
    <updated>2025-06-13T01:54:40.494Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Go 语言的并发模型是其强大之处之一，而 Channel 则是这一模型的核心。Channel 提供了一种在 goroutine 之间进行通信和同步的机制。然而，正确地使用 Channel 并不是一件简单的事情。&lt;/p&gt;
&lt;p&gt;本文将详细介绍在 Go 语言中使用</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Go 中获取 goroutine 的 ID？</title>
    <link href="https://pudongping.github.io/posts/2dcc2ce.html"/>
    <id>https://pudongping.github.io/posts/2dcc2ce.html</id>
    <published>2025-06-12T02:31:29.000Z</published>
    <updated>2025-06-12T02:32:17.332Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在使用 Go 语言进行并发编程时，Goroutine 是一种轻量级线程，具有很高的性能优势。然而，Go 语言&lt;strong&gt;并未直接提供&lt;/strong&gt;获取 Goroutine ID 的官方 API。这是 Go 语言设计的一部分，目的是避免开发者依赖 Goroutine</summary>
        
      
    
    
    
    <category term="Go" scheme="https://pudongping.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://pudongping.github.io/tags/Go/"/>
    
    <category term="Golang" scheme="https://pudongping.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
